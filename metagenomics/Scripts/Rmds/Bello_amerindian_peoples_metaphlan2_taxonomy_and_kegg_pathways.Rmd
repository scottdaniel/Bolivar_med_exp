---
title: "Basic Bioinformatics Overview for fecal microbiome\nof the Yekwana and Sanema peoples"
author: "Scott G. Daniel, PennCHOP Microbiome Program"
date: \today
geometry: margin=3cm
output: 
    pdf_document:
      includes:
        in_header: ~/TeX_packages_commands.sty
      keep_tex: yes
      latex_engine: xelatex
      template: toc_after.tex
      toc: yes
---
![' '](logo_blk.png)\

\tableofcontents

```{r setup, echo=FALSE}
knitr::opts_chunk$set(
  tidy=FALSE,
  cache=FALSE,
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  dpi=100,
  fig.width=8,
  fig.height=8,
  fig.align = "center"
  )
```

```{r libraries, message=FALSE, warning=FALSE}
library(KEGGREST)
library(ggbeeswarm)
library(grid)
library(magrittr)
library(pander)
library(pheatmap)
library(usedist)
library(qiimer)
library(reshape2)
library(pander)
library(jsonlite)
library(vegan)
library(ape)
library(tidyverse)
library(RColorBrewer)
library(viridis)
library(here)
```

```{r functions}

source(here("metagenomics","Scripts","Functions","common_functions.R"))
source(here("metagenomics","Scripts","Functions","scott_daniel_useful_R_functions.R"))

```

```{r constants and file paths}
### number of samples threshold to show heatmap on the page
sample_threshold <- 100

### minimum reads to show on heatmap
min_reads <- 30000

# These files are usually generated by https://github.com/PennChopMicrobiomeProgram/reportGeneration/blob/master/generate_report_files.sh
# Or Target_Reports in Sunbeam's rules


### mapping file path
mapping_file_fp <- here::here("metagenomics/Data","bello_mapping_table_LCDM7AANXX.tsv")

### preprocess summary results filepath
preprocess_fp <- here::here("metagenomics/Data","preprocess_summary.tsv")

### kraken_summary

kraken_summary_fp <- here::here("metagenomics/Data","kraken_summary.txt")

### read quality
fastqc_fp = here::here("metagenomics/Data","fastqc_quality.tsv")

### taxonomic assignment 
feature_table_fp <- here::here("metagenomics/Data","all_samples.tsv")

### KEGG orthology assignment
kegg_fp <- here::here("metagenomics/Data","ko_assignments.tsv")
```

```{r sample_sheet_import, echo=FALSE}
s <- read.delim(mapping_file_fp, sep='\t') %>%
  mutate(SampleID = as.character(SampleID)) %>%
  mutate(isControl = grepl('Extract|vibriolamda|EBneg', SampleID))

color_by <- NULL
shape_by <- NULL
potential_headers <- c('study_group', 'ethnicity', 'village')
header_idx <- which(is.element(potential_headers, colnames(s)))

if(length(header_idx)>0){
  color_by <- potential_headers[header_idx[1]]
}
if(length(header_idx)>1){
  shape_by <- potential_headers[header_idx[2]]
}

quality_summary_headers <- c('ethnicity', 'village')
header_idx <- which(is.element(quality_summary_headers, colnames(s)))
quality_by <- ifelse(length(header_idx)>0, quality_summary_headers[header_idx[1]], NULL)

all_dates <- as.character(unique(s$run_start_date))
run_date <- paste(lapply(all_dates, change_data_format), collapse=', ')
investigator <- paste(unique(s$investigator), collapse = ", ")
investigator <- gsub("(^|[[:space:]])([[:alpha:]])", "\\1\\U\\2", investigator, perl=TRUE)
```

```{r data import}
preprocess <- read.delim(preprocess_fp) %>%
  mutate(Samples = sub(".json", "", Samples))

kraken_unclass <- read.delim(kraken_summary_fp, header = F) %>%
  select(Filename = V1, percent_unclass = V2, count_unclass = V3) %>%
  mutate(SampleID = str_replace(Filename, fixed("-taxa.tsv"), "")) %>%
  select(-Filename) %>%
  left_join((preprocess %>% select(SampleID = Samples, count_class = nonhost)), by = "SampleID")

o <- read_qiime_otu_table(feature_table_fp)

# Metadata in the form of truncated green genes assignments
md <- sub("(; [kpcofgs]__)+$", "", o$metadata, perl=T)
md <- gsub("[kpcofgs]__", "", md)  

# Assignments data-frame
adf <- split_assignments(md) %>%
  mutate(Species = ifelse(!is.na(Genus) & !is.na(Species), paste(Genus, Species), NA))
a <- simplify_assignments(adf, rank1 = "Phylum", rank2="Species")

cts <- o$counts
colnames(cts) <- sub("\\.taxa$", "", colnames(cts))

cts_props <- sweep(cts, 2, colSums(cts), "/")
summed_cts <- rowsum(cts, a) 
summed_props <- sweep(summed_cts, 2, colSums(summed_cts), "/")

```

\newpage

# Introduction

This report is based on the results of sequencing performed on `r run_date` for Gloria Dominguez-Bello. 

# Demultiplexing and quality control

## Number of read pairs per sample after demultiplexing

Samples were sequenced on Hiseq 2500 and demultiplexed. The demultiplexing step involves matching the barcode sequences assicated with each sample to the sequence each read is tagged with.

```{r echo=FALSE}
preprocess %>%
  mutate(num_seq=input/1000000) %>%
  merge(s[c("SampleID", "SampleType")], by.y="SampleID", by.x="Samples") %>%
  ggplot(aes(x=num_seq)) +
    geom_histogram(aes(fill=SampleType), binwidth=0.2) +
    theme_bw() + 
    labs(
      x="Number of read pairs in sample (millions, M)",
      y="Number of samples"
    )
ggsave(here("metagenomics","Output","summary_dnabc.pdf"), width=7, height=5, useDingbats=F)
```

\newpage

## Average nucleotide quality after adapter trimming and quality control

Nextera-XT adapters were removed using trimmomatic-0.33. Nucleotide quality for each position was averaged across all reads using FASTQC.

```{r echo=FALSE}

qc_df <- read.delim(fastqc_fp, sep='\t') %>%
  melt(id.vars="Samples", variable.name="Position", value.name = "Quality") %>%
  mutate(
    Position = sub("X", "", Position),
    Position = sub("\\.\\d+", "", Position, perl = TRUE),
    Position = as.numeric(Position)) %>%
  mutate(SampleID=sub("^(.*)_([12])$", "\\1", Samples), Direction=sub("^(.*)_([12])$", "\\2", Samples)) %>%
  mutate(Direction = factor(Direction)) %>%
  group_by(Direction, Position) %>%
  summarise(MeanQual = mean(Quality), SdQual = sd(Quality)) %>%
  mutate(LowQual = MeanQual - SdQual, HighQual = MeanQual + SdQual) %>%
  ungroup()


qc_df %>%
  ggplot(aes(x=Position, y=MeanQual)) + 
    geom_errorbar(aes(ymin=LowQual, ymax=HighQual)) +
    facet_wrap(~ Direction) +
    geom_line() +
    geom_point() +
    theme_bw() + 
    labs(x='Position in sequence read', y='Average quality score per sample')
ggsave(here("metagenomics","Output",'quality_after.pdf'), width=7, height=5, useDingbats=F)
```

\newpage

## Overall distribution of percentage reads removed in quality control

The low quality reads defined by Trimmomatic-0.33 were discarded from further analysis. Human DNA was filtered using BWA with HG38 version of human genome as reference. Reads mapping to the PhiX genome was also removed. Only the reads tagged as non-human were analyzed further.

```{r echo=FALSE}
preprocess %>%
  mutate(low_quality = (fwd_only + rev_only + dropped) / input) %>%
  mutate(human = host / input) %>%
  mutate(non_human = nonhost / input) %>%
  merge(s[c("SampleID", "isControl", quality_by)], by.y="SampleID", by.x="Samples") %>%
  filter(!isControl) %>%
  arrange(desc(human)) %>%
  mutate(Sample_num=row_number()) %>%
  melt(c("Sample_num", quality_by), c("low_quality", "human", "non_human")) %>%
  ggplot(aes(x=Sample_num, y=value)) +
    geom_area(aes(fill=variable), position='stack') + 
    facet_grid(.~eval(parse(text=quality_by)), scales = "free_x") +
    scale_fill_brewer(palette="Set1") + 
    theme(axis.text.x = element_blank()) +
    scale_x_continuous(expand=c(0,0)) +
    scale_y_continuous(expand=c(0,0), labels=scales:::percent) +
    labs(x="Samples", y="Percentage of reads", fill="")
ggsave(here("metagenomics","Output",'preprocess_summary.pdf'), width=5, height=7, useDingbats=F)
```

\newpage

## Percentage unclassified

Taxonomic assignments were performed using the Kraken program. Tribal datasets are expected to contain a large number of unidentified species as the kraken reference databases are biased towards already-known species. This graph illustrates this:

```{r echo=FALSE}
kraken_unclass %>%
  merge(s[c("SampleID","isControl", "study_group")], by="SampleID") %>%
  filter(!isControl) %>%
  arrange(desc(percent_unclass)) %>%
  mutate(`Percent classified` = 100 - percent_unclass) %>%
  mutate(Sample_num=row_number()) %>%
  rename(`Percent unclassified` = percent_unclass) %>%
  melt(c("Sample_num", "study_group"), c("Percent unclassified", "Percent classified")) %>%
  ggplot(aes(x=Sample_num, y=value)) +
    geom_area(aes(fill=variable), position='stack') + 
    facet_grid(~study_group, scales = "free_x") +
    #scale_fill_brewer(palette="Set1") + 
    theme(axis.text.x = element_blank()) +
    scale_x_continuous(expand=c(0,0)) +
    scale_y_continuous(expand=c(0,0)) + #, labels=scales:::percent) +
    labs(x="Samples", y="Percentage of reads", fill="")

ggsave(here("metagenomics","Output",'kraken_unclassified_summary.pdf'), width=5, height=7, useDingbats=F)
```

\newpage

# Taxonomic assignments

```{r}
prop_cut <- 0.01
satu_limit <- 0.4
heatmap_fp <- "taxonomy_heatmap_1perc.pdf"
heatmap_fp_controls <- "taxonomy_heatmap_with_controls_1perc.pdf"
show.text <- nrow(s) > sample_threshold
```

Taxonomic assignments were performed using the Kraken program.

Heatmap charts were generated from the taxonomic assignments. Each column represents one sample and each row represents one taxon (typically a species). Ranks are included in the plot if the taxon is present in `r 100*prop_cut`% abundance in at least one sample.

The chart is colored white if species were not observed in the sample, dark blue if species were observed at very low abundance.  This allows the reader to quickly survey species presence/absence.  Abundance values exceeding 40% are colored red, indicating an extremely dominant species.

Cdiff shows up in EBneg1 and EBneg2 but it is no cause for concern. Each of them have <100 reads classified as such.

See `r heatmap_fp_controls` for the same heatmap but with all controls.

\blandscape

```{r heatmap time, fig.width=50, fig.height=30, out.width="70%"}

sample_threshold <- 100

read_counts <- preprocess %>%
  select(SampleID = Samples, Read_Counts = both_kept)

s2 <- merge(s, read_counts, by="SampleID", all=T) %>%
  mutate(Keep = if_else(is.na(Read_Counts), FALSE, TRUE)) %>%
  mutate(Keep = Read_Counts > min_reads) %>%
  mutate(isControl = grepl("EBneg.*|Extract.*|vibrio.*", SampleID, ignore.case = TRUE))

s_toPlot <- s2 %>%
  filter(Keep) %>%
  filter(!isControl)

#props_toPlot <- summed_props[grep("phage|sapiens", rownames(summed_props), invert = T), s_toPlot$SampleID]
props_toPlot <- summed_props[, s_toPlot$SampleID]
grps <- c("study_group","ethnicity","village")

### grouped heatmap
heatmap_grouped(props_toPlot, s_toPlot, grps=grps, option=2, prop_cut = prop_cut, satu_limit=satu_limit)


heatmap_grouped(props_toPlot, s_toPlot, grps=grps, option=2, prop_cut = prop_cut, satu_limit=satu_limit, here("metagenomics","Output", heatmap_fp))


```


```{r heatmap with controls, fig.width=16, fig.height=12}
s_toPlot <- s2 %>%
  mutate(SampleType = fct_relevel(SampleType, "Blank tip", "Empty well",
                                  "EB"))

#props_toPlot <- summed_props[grep("phage|sapiens", rownames(summed_props), invert = T), s_toPlot$SampleID]
props_toPlot <- summed_props[, s_toPlot$SampleID]

heatmap_grouped(props_toPlot, s_toPlot, grps=grps, thre=0.01, option=2, prop_cut = prop_cut, satu_limit=satu_limit, here("metagenomics","Output", heatmap_fp_controls))

### top species
# top <- top_table(props_toPlot, s_toPlot, thre=0.01, option=2, prop_cut = prop_cut)
# 
# top$avg_prop <- apply(top,1,mean)
# 
# top <- top %>%
#   rownames_to_column() %>%
#   rename(Taxa = rowname) %>%
#   filter(!row.names(top) %in% c("g__; s__")) %>%
#   mutate(Taxa = gsub("g__","",Taxa)) %>%
#   mutate(Taxa = gsub("; s__"," ", Taxa)) %>%
#   arrange(desc(avg_prop))

```



\elandscape



```{r eval=FALSE, include=FALSE}
# Fungal genome contig segment coverage

# Mapping was done using bowtie2 and six fungal genomes:
# 
# -- Candida albicans
# 
# -- Candida auris
# 
# -- Clavispora lusitaniae
# 
# -- Cyberlindnera jadinii
# 
# -- Kluyveromyces marxianus
# 
# -- Saccharomyces cerevisiae

## Fungal heatmaps
## Skipping for now because this is supplementary to what Bello probably wants
## This is more for the Candida auris sub-project
s_Fungi <- s2 %>%
  filter(!isControl)

fungal_cts <- read_csv(here::here("fungi_coverage.csv")) %>%
  mutate(ratio = `Segment Coverage` / `Segment Length`)

fungal_ann <- read_tsv(here::here("fungi_species_strain.ann.tsv"))

fungal_ann <- fungal_ann %>% 
  mutate(short_Segment = str_extract(Segment, boundary("word"))) %>%
  select(-Segment) %>%
  rename(Segment = short_Segment)

fungal_cts <- fungal_cts %>%
  merge(fungal_ann)

fungal_cts %>%
  merge(s_Fungi, by.x = "Sample", by.y = "SampleID") %>%
ggplot(aes(x=species, y=ratio, color=study_group)) +
  geom_boxplot() +
  scale_y_continuous(labels=scales:::percent) +
  theme_bw() +
  theme(axis.text.x=element_text(angle=-25, hjust= .1)) +
labs(
    x="Species", color="Medium urban\n = tribes reachable\nby car/bus\n\nLow urban\n = tribes only\nreachable by helicopter",
    y="Percent covered per segment (Segment coverage / Segment length)",
    title="Boxplot of segment coverage for fungal species\nfor Venezuelan indigenous tribes\nSangema and Yekwana"
  )
  
ggsave("fungi_perc_segment_covered.pdf", width=7, height=8)


```

```{r eval=FALSE, include=FALSE}

for (j in 1:length(unique(fungal_cts$species))) {
p <- fungal_cts %>%
  merge(s_Fungi, by.x = "Sample", by.y = "SampleID") %>%
  filter(!`Segment Coverage`==0) %>%
    filter(species %in% unique(fungal_cts$species)[j]) %>%
ggplot(aes(x=Segment, y=ratio)) +
  geom_boxplot() +
  facet_grid(~species) +
  scale_y_continuous(labels=scales:::percent) +
  theme_bw() +
  theme(axis.text.x=element_blank()) +
labs(
    x="Contigs / Chromosomes",
    y="Percent covered per segment (Segment coverage / Segment length)",
    title="Boxplot of segment coverage for fungal species\nfor Venezuelan indigenous tribes\nSangema and Yekwana"
  )
plot(p)
}

```

```{r eval=FALSE, include=FALSE}

### Length vs. Height

#More insight may be gained by plotting % coverage (length) against avg. coverage depth (height):

for (j in 1:length(unique(fungal_cts$species))) {
p <- fungal_cts %>%
  merge(s_Fungi, by.x = "Sample", by.y = "SampleID") %>%
   select(Sample, `Avg. coverage depth` = Mean,
         `Perc. genome covered` = ratio, 
         study_group, Segment, `Segment Coverage`, species) %>%
  arrange(desc(Segment)) %>%
  filter(!`Segment Coverage`==0) %>%
  filter(species %in% unique(fungal_cts$species)[j]) %>%
    ggplot(aes(x=`Avg. coverage depth`, y=`Perc. genome covered`)) +
  geom_point() +
  facet_grid(~species) +
scale_y_continuous(labels=scales:::percent) +
  theme_bw() +
labs(
    x="Average coverage depth",
    y="Percent segment covered",
    title=""
  )
plot(p)
}

```

# Beta diversity

```{r}
s_toPlot <- s2 %>%
  filter(Keep) %>%
  filter(!isControl) %>%
  filter(str_detect(SampleID, "vibrio.*", negate = T))
```

## Bray-Curtis distance

### PCoA plot based on Bray-Curtis distance

Here, we use Bray-Curtis distance to compare the species composition of the samples to each other.

The first plot shows the distance between each pair of samples in a single 2D plot.  It is not possible to plot the distances exactly on paper, so we have used a method of ordination called Principal Coordinates Analysis to select the best coordinate system for display.  The percentage of total variance captured along each axis is displayed on the chart.

```{r, fig.width=6, fig.height=6}
bc <- vegdist(t(cts_props))
dist_in <- usedist::dist_subset(bc, s_toPlot$SampleID)
plot(make_pcoa_plot(dm = dist_in, s = s_toPlot, color_by="study_group", shape_by="ethnicity"))

#manual
plot(make_pcoa_plot(dist_in, s_toPlot, color_by="ethnicity", shape_by="village"))
```

\newpage



```{r}
#Permanova on Bray-Curis distance
# ad1 <- s_toPlot %$%
#   adonis(dist_in ~ study_group + ethnicity + village)
# 
# ad1 <- s_toPlot %$%
#   adonis(dist_in ~ village)
# 
# print(ad1)

```

### Hierarchical clustering based on Bray-Curtis distance

The second plot shows sample clustering based on Bray-Curtis distance.  We have used a method of hierarchical clustering called "average-linkage" or UPGMA.  At the bottom of the dendrogram, all samples start out in their own group.  Moving up the dendrogram, samples accumulate into clusters if the average (mean) distance between all samples is below the indicated value.

```{r fig.width=15}
bc_upgma <- hclust(usedist::dist_subset(bc, s_toPlot$SampleID), method = "average")
plot(
  bc_upgma, hang=-1, main="",
  ylab = "Bray-Curtis distance",
  xlab="Hierarchical clustering",
  sub="Average-linkage method (UPGMA)")
```

\newpage

## Jaccard distance

Here, we use Jaccard distance to compare samples based on shared species membership.  Plots are described above.

### PCoA plot based on Jaccard distance

```{r, fig.width=6, fig.height=6}
jd <- vegdist(t(cts_props), binary=TRUE)

dist_in <- usedist::dist_subset(jd, s_toPlot$SampleID)
plot(make_pcoa_plot(dist_in, s_toPlot,  color_by="study_group", shape_by="ethnicity"))
```

\newpage

### Hierarchical clustering based on Jaccard distance

```{r fig.width=15}
jd_upgma <- hclust(usedist::dist_subset(jd, s_toPlot$SampleID), method = "average")
plot(
  jd_upgma, hang=-1, main="",
  ylab = "Jaccard distance",
  xlab="Hierarchical clsutering",
  sub="Average-linkage method (UPGMA)")
```

\newpage

# Results based on psuedo-16S pipeline

These results are based on running vsearch global alignment with the query being all the demultiplexed, dereplicated, and filtered reads against a fasta database of the greengenes 16S sequences. Then, reads that aligned were used as input into Qiime2's 16S pipeline, again using greengenes as a reference database to generate a feature table and taxonomic tree. We rarified the samples to 1,000 read counts per sample because otherwise we are dealing with 1.6M features.

```{r}
### ===========================
###   define constants
### ===========================

### minimum reads threshold
min_reads <- 1000

### rarefying subsample size 
richness_subsample_size <- 1000

### number of samples threshold to show heatmap on the page
sample_threshold <- 100

### otu table file path
feature_table_fp <- here::here("metagenomics/Data","rarified/table/feature-table.tsv")

### taxonomic assignment 
taxo_assignment_fp <- here::here("metagenomics/Data","taxonomy.tsv")

```

```{r, warning=F}
### ===========================
###   read in data
### ===========================

### read mapping file
s_initial <- read_qiime_mapping_file(mapping_file_fp) 

### read otu table
counts <- readr::read_delim(feature_table_fp, skip=1, delim="\t") %>%
  column_to_rownames(var = "#OTU ID") %>%
  as.matrix()

### get read counts
read_counts <- colSums(counts) %>% 
  as.data.frame() %>%
  setNames(c("Read_Counts")) %>%
  rownames_to_column(var="SampleID")

#trun_taxon perl expression is to get rid of trailing "; s__" since it doesn't add any new information

### taxonomic assignment
ta_initial <- read_delim(file=taxo_assignment_fp, delim="\t") %>%
  mutate(trunc_taxon = sub('(; [kpcofgs]__)+$', "", Taxon, perl=T))

features <- row.names(counts)

ta <- ta_initial %>% filter(`Feature ID` %in% features) %>%
  arrange(order(match(rownames(counts), `Feature ID`)))

### check if the order of the assignments and the order of featue table is the same
if (!all(rownames(counts) == ta$`Feature ID`)) {
  stop (simpleError("The order of the features in the table and classifications don't match"))
}

adf <- split_assignments(ta$trunc_taxon) 

### remove contamination
is_mitochondrial <- grepl("mitochondria", adf$Family)
is_chloroplast <- grepl("Chloroplast", adf$Class)
is_unassigned <- grepl("Unassigned", adf$Kingdom)
is_archaea <- grepl("Archaea", adf$Kingdom)
is_contam <- is_mitochondrial | is_chloroplast | is_unassigned ### Archaea kept to check positive control samples
counts <- counts[!is_contam,]
adf <- adf[!is_contam,]
ta <- ta[!is_contam,]
rm(is_contam, is_mitochondrial, is_chloroplast, is_unassigned, is_archaea)

a <- simplify_assignments(adf, rank1="Phylum", rank2="Genus")
names(a) <- ta$`Feature ID`
summed_cts <- rowsum(counts, a) 
summed_props <- sweep(summed_cts, 2, colSums(summed_cts), "/")

#if we want all the otus
# all_otus <- counts %>%
#   merge(ta[,c("Feature ID","Confidence","trunc_taxon")], by.x="row.names", by.y="Feature ID", all.x=T) %>%
#   dplyr::rename(Taxon = trunc_taxon) %>%
#   dplyr::rename(`Feature ID` = Row.names)
# 
# write.csv(x = all_otus, file = "all_otus.csv", row.names = F)

secszehn_props <- summed_props
secszehn_taxa <- row.names(filter_rare_taxa(summed_props, prop_cut = 0.01))

```

## Taxonomic heatmap based on pseudo-16S pipeline

```{r}
prop_cut <- 0.01
satu_limit <- 0.4
heatmap_fp <- "otu_heatmap.pdf"
show.text <- sum(s$Keep) > sample_threshold
```

Each column of the heatmap represents one sample and each row represents one taxon, typically a genus. Taxa were included in the chart if the abundance in any sample exceeded `r 100*prop_cut`%. 

The chart is colored white if taxa were not observed in the sample, dark blue if taxa were observed at very low abundance. This allows the reader to quickly survey presence/absence. Abundance values exceeding `r 100*satu_limit`% are colored red, indicating an extremely dominant species.

`r paste0("Also see separate plot ", heatmap_fp, ".")`

```{r, fig.height=12, fig.width=16}
s_toPlot <- s  %>%
  filter(!isControl)

props_toPlot <- summed_props[, s_toPlot$SampleID]  
grps <- c("study_group","ethnicity","village")

### grouped heatmap
heatmap_grouped(props_toPlot, s_toPlot, grps=grps, thre=0.01, option=2, prop_cut = prop_cut, satu_limit=satu_limit)

heatmap_grouped(props_toPlot, s_toPlot, grps=grps, thre=0.01, option=2, prop_cut = prop_cut, satu_limit=satu_limit, here("metagenomics","Output", heatmap_fp))
```

# Results based on kraken_tribal mapping.

Using an alternate database that included bacteria, archaea, protozoa, fungi, viruses, and parasitic nematodes.

```{r data import 2}

kraken_unclass_t <- read.delim(here("metagenomics/Data","tribal_kraken_summary.txt"), header = F) %>%
  select(Filename = V1, percent_unclass = V2, count_unclass = V3) %>%
  mutate(SampleID = str_replace(Filename, fixed("-taxa.tsv"), "")) %>%
  select(-Filename) %>%
  left_join((preprocess %>% select(SampleID = Samples, count_class = nonhost)), by = "SampleID")

o <- read_qiime_otu_table(here("metagenomics/Data","tribal_all_samples.tsv"))

# Metadata in the form of truncated green genes assignments
md <- sub("(; [kpcofgs]__)+$", "", o$metadata, perl=T)
md <- gsub("[kpcofgs]__", "", md)  

# Assignments data-frame
adf <- split_assignments(md) %>%
  mutate(Species = ifelse(!is.na(Genus) & !is.na(Species), paste(Genus, Species), NA))
a <- simplify_assignments(adf, rank1 = "Phylum", rank2="Species")

cts <- o$counts
colnames(cts) <- sub("\\.taxa$", "", colnames(cts))

cts_props <- sweep(cts, 2, colSums(cts), "/")
summed_cts <- rowsum(cts, a) 
summed_props <- sweep(summed_cts, 2, colSums(summed_cts), "/")

```

## Percentage unclassified

```{r echo=FALSE}

k1 <- bind_cols(kraken_unclass, db = rep_len("kraken_standard",93))
k2 <- bind_cols(kraken_unclass_t, db = rep_len("kraken_tribal",93))
kraken_unclass_combined <- bind_rows(k1,k2)

kraken_unclass_combined %>%
  merge(s[c("SampleID","isControl", "study_group")], by="SampleID") %>%
  filter(!isControl & !is.na(study_group)) %>%
  arrange(desc(SampleID)) %>%
  mutate(`Percent classified` = 100 - percent_unclass) %>%
  mutate(Sample_num=row_number()) %>%
  rename(`Percent unclassified` = percent_unclass) %>%
  melt(c("Sample_num", "db"), c("Percent unclassified", "Percent classified")) %>%
  ggplot(aes(x=Sample_num, y=value)) +
    geom_area(aes(fill=variable), position='stack') + 
    facet_grid(~db, scales = "free_x") +
    #scale_fill_brewer(palette="Set1") + 
    theme(axis.text.x = element_blank()) +
    scale_x_continuous(expand=c(0,0)) +
    scale_y_continuous(expand=c(0,0)) + #, labels=scales:::percent) +
    labs(x="Samples", y="Percentage of reads", fill="", title = "Comparison of kraken databases")
ggsave(here("metagenomics","Output",'kraken_unclassified_summary_kraken_tribal.pdf'), width=5, height=7, useDingbats=F)
```

It looks like the custom databse had a slightly higher overall classification. A simple calculation shows this: Avg. unclassified percentage for kraken standard db vs. Avg. unclassificed percentage for kraken "tribal" db: `r paste0(mean(kraken_unclass$percent_unclass),"%")` vs. `r paste0(mean(kraken_unclass_t$percent_unclass),"%")`.

Despite only being a 2% improvement on classification, let us look at the taxonomic composition.

# Taxonomic assignments

```{r}
prop_cut <- 0.01
satu_limit <- 0.4
heatmap_fp <- "tribal_taxonomy_heatmap_1perc.pdf"
heatmap_fp_controls <- "tribal_taxonomy_heatmap_with_controls_1perc.pdf"
show.text <- nrow(s) > sample_threshold
```

Taxonomic assignments were performed using the Kraken program.

Heatmap charts were generated from the taxonomic assignments. Each column represents one sample and each row represents one taxon (typically a species). Ranks are included in the plot if the taxon is present in `r 100*prop_cut`% abundance in at least one sample.

The chart is colored white if species were not observed in the sample, dark blue if species were observed at very low abundance.  This allows the reader to quickly survey species presence/absence.  Abundance values exceeding 40% are colored red, indicating an extremely dominant species.

Cdiff shows up in EBneg1 and EBneg2 but it is no cause for concern. Each of them have <100 reads classified as such.

See `r heatmap_fp_controls` for the same heatmap but with all controls.

\blandscape

```{r, fig.width=50, fig.height=30, out.width="70%"}

sample_threshold <- 100

read_counts <- preprocess %>%
  select(SampleID = Samples, Read_Counts = both_kept)

s2 <- merge(s_initial, read_counts, by="SampleID", all=T) %>%
  mutate(Keep = if_else(is.na(Read_Counts), FALSE, TRUE)) %>%
  mutate(Keep = Read_Counts > min_reads) %>%
  mutate(isControl = grepl("EBneg.*|Extract.*|vibrio.*", SampleID, ignore.case = TRUE))

s_toPlot <- s2 %>%
  filter(Keep) %>%
  filter(!isControl)

#props_toPlot <- summed_props[grep("phage|sapiens", rownames(summed_props), invert = T), s_toPlot$SampleID]
props_toPlot <- summed_props[, s_toPlot$SampleID]
grps <- c("study_group","ethnicity","village")

### grouped heatmap
heatmap_grouped(props_toPlot, s_toPlot, grps=grps, option=2, prop_cut = prop_cut, satu_limit=satu_limit)


heatmap_grouped(props_toPlot, s_toPlot, grps=grps, option=2, prop_cut = prop_cut, satu_limit=satu_limit, here("metagenomics","Output", heatmap_fp))


```


```{r, fig.width=16, fig.height=12}
s_toPlot <- s2 %>%
  mutate(SampleType = fct_relevel(SampleType, "Blank tip", "Empty well",
                                  "EB"))

#props_toPlot <- summed_props[grep("phage|sapiens", rownames(summed_props), invert = T), s_toPlot$SampleID]
props_toPlot <- summed_props[, s_toPlot$SampleID]

heatmap_grouped(props_toPlot, s_toPlot, grps=grps, thre=0.01, option=2, prop_cut = prop_cut, satu_limit=satu_limit, here("metagenomics","Output", heatmap_fp_controls))

### top species
# top <- top_table(props_toPlot, s_toPlot, thre=0.01, option=2, prop_cut = prop_cut)
# 
# top$avg_prop <- apply(top,1,mean)
# 
# top <- top %>%
#   rownames_to_column() %>%
#   rename(Taxa = rowname) %>%
#   filter(!row.names(top) %in% c("g__; s__")) %>%
#   mutate(Taxa = gsub("g__","",Taxa)) %>%
#   mutate(Taxa = gsub("; s__"," ", Taxa)) %>%
#   arrange(desc(avg_prop))

```

\elandscape

The overall composition looks very similar. We do know that its a different database because of the appearance of Fungi like Neurospora.

# Metaphlan

Let us see if Metaphlan is any better at classification.

```{r data import 3}

# kraken_unclass_t <- read.delim("tribal_kraken_summary.txt", header = F) %>%
#   select(Filename = V1, percent_unclass = V2, count_unclass = V3) %>%
#   mutate(SampleID = str_replace(Filename, fixed("-taxa.tsv"), "")) %>%
#   select(-Filename) %>%
#   left_join((preprocess %>% select(SampleID = Samples, count_class = nonhost)), by = "SampleID")

clean_taxonomy <- function(props){
  # take out viruses and normalize again
  props <- props[-grep('k__Viruses', rownames(props)),]
  props <- sweep(props, 2, colSums(props), "/")
}

o2 <- read_tsv(here("metagenomics/Data","metaphlan_taxonomic_assignments.tsv")) %>%
  column_to_rownames(var = "Term") %>%
  clean_taxonomy()

# Metadata in the form of truncated green genes assignments
md <- sub("(; [kpcofgs]__)+$", "", rownames(o2), perl=T)
md <- gsub("[kpcofgs]__", "", md)  

# Assignments data-frame
adf <- split_assignments(md, split="\\|") %>%
  mutate(Species = ifelse(!is.na(Genus) & !is.na(Species), paste(Genus, Species), NA))

a <- simplify_assignments(adf, rank1 = "Phylum", rank2="Species")

props <- rowsum(o2, a)
colnames(props) <- sub("_review$", "", colnames(props))

a_g <- simplify_assignments(adf, rank2="Genus")
props_g <- rowsum(props, a_g)

a_p <- as.character(adf$Phylum)
a_p[is.na(a_p)] <- "unclassified"
props_p <- rowsum(props, a_p)

#For comparison to the 16s results

#Want to only keep Bacteria so need to clean the taxonomy again

metaphlan_prop_func <- function() {
  clean_taxonomy <- function(props){
    # just keep bacteria and normalize again
    props <- props[grep('k__Bacteria', rownames(props)),]
    props <- sweep(props, 2, colSums(props), "/")
  }
  o2 <- read_tsv(here("metagenomics/Data","metaphlan_taxonomic_assignments.tsv")) %>%
    column_to_rownames(var = "Term") %>%
    clean_taxonomy()
  # Metadata in the form of truncated green genes assignments
  md <- sub("(; [kpcofgs]__)+$", "", rownames(o2), perl=T)
  md <- gsub("[kpcofgs]__", "", md)  
  # Assignments data-frame
  adf <- split_assignments(md, split="\\|") %>%
    mutate(Species = ifelse(!is.na(Genus) & !is.na(Species), paste(Genus, Species), NA))
  a <- simplify_assignments(adf, rank1 = "Phylum", rank2="Species")
  props <- rowsum(o2, a)
  colnames(props) <- sub("_review$", "", colnames(props))
  a_g <- simplify_assignments(adf, rank2="Genus")
  props_g <- rowsum(props, a_g)
  return(props_g)
}

metaphlan_props <- metaphlan_prop_func() 

metaphlan_props %<>%
  replace_na(list(EBneg1 = 0,
                  EBneg2 = 0, 
                  Extractblanktip1 = 0, 
                  Extractblanktip2 = 0,
                  Extractemptywell1 = 0,
                  Extractemptywell2 = 0))

metaphlan_taxa <- row.names(filter_rare_taxa(metaphlan_props, prop_cut = 0.01))

```

## Taxonomic heatmap based metaphlan results

```{r}
prop_cut <- 0.01
thre <- 0.4
satu_limit <- 0.4
heatmap_fp <- "metaphlan_heatmap.pdf"
show.text <- sum(s$Keep) > sample_threshold
```

Each column of the heatmap represents one sample and each row represents one taxon, typically a genus. Taxa were included in the chart if they were nonzero in at least `r 100*thre`% of the samples.

The chart is colored white if taxa were not observed in the sample, dark blue if taxa were observed at very low abundance. This allows the reader to quickly survey presence/absence. Abundance values exceeding `r 100*satu_limit`% are colored red, indicating an extremely dominant species.

`r paste0("Also see separate plot ", heatmap_fp, ".")`

```{r, fig.height=12, fig.width=16}
#Taxa were included in the chart if the abundance in any sample exceeded `r 100*prop_cut`%. 

s_toPlot <- s2 %>%
  filter(Keep) %>%
  filter(!isControl)

props_toPlot <- props[, s_toPlot$SampleID]  
grps <- c("study_group","ethnicity","village")

### grouped heatmap
heatmap_grouped(props_toPlot, s_toPlot, grps=grps, thre = thre, option=1, prop_cut = prop_cut, satu_limit=satu_limit)

heatmap_grouped(props_toPlot, s_toPlot, grps=grps, thre = thre, option=1, prop_cut = prop_cut, satu_limit=satu_limit, here("metagenomics","Output", heatmap_fp))
```

## Bray-Curtis distance based on metaphlan

### PCoA plot based on Bray-Curtis distance

Here, we use Bray-Curtis distance to compare the species composition of the samples to each other.

The first plot shows the distance between each pair of samples in a single 2D plot.  It is not possible to plot the distances exactly on paper, so we have used a method of ordination called Principal Coordinates Analysis to select the best coordinate system for display.  The percentage of total variance captured along each axis is displayed on the chart.

```{r, fig.width=6, fig.height=6}
bc <- vegdist(t(props))
dist_in <- usedist::dist_subset(bc, s_toPlot$SampleID)
plot(make_pcoa_plot(dm = dist_in, s = s_toPlot, color_by="study_group", shape_by="ethnicity"))

#manual
plot(make_pcoa_plot(dist_in, s_toPlot, color_by="ethnicity", shape_by="village"))
```

\newpage

#Permanova on Bray-Curis distance

```{r}

# ad1 <- s_toPlot %$%
#   adonis(dist_in ~ study_group + ethnicity + village)

ad1 <- s_toPlot %$%
  adonis(dist_in ~ village)

#library(stargazer)

print(ad1)

ad1 <- s_toPlot %$%
  adonis(dist_in ~ ethnicity)

print(ad1)

```

#How many metaphlan reads had hits?

```{r}

metaphlan_hit_counts <- read_tsv(here("metagenomics/Data","metaphlan_hit_counts.tsv"))

preprocess %>%
  mutate(actual_read_count = nonhost * 2) %>%
  left_join(metaphlan_hit_counts, by = c("Samples" = "SampleID")) %>%
  mutate(percent_classified = paste0(round(100 * Metaphlan_hits / actual_read_count, digits = 2),"%")) %>%
  #write_tsv(.,"metaphlan_classification_results.tsv")
  select(Samples, Metaphlan_hits, Reads = actual_read_count, percent_classified) %>%
  pander(split.table=Inf)

```

<!-- #Calculate overlap between metaphlan and 16S results as shown in the report -->

<!-- We are interested in the similarity of metaphlan and "pseudo-16s" results. This venn diagram shows the genus level overlap for the two methods. It is genus level since the 16s results are only  >90% accurate to that level (Only about ~70% accurate at species level). -->

<!-- These only include genus' that are at least 1% or greater in one sample. The low number of genus' in the 16s results are expected given the limitations of 16s methods. -->

```{r eval=FALSE, include=FALSE}

genus_in_16s <- str_extract(secszehn_taxa, ".*g__.*") %>% tibble() %>% filter(!is.na(.)) %>% set_names("Phylum_Genus")

genus_in_16s %<>% mutate(Phylum_Genus = str_replace(Phylum_Genus, ".+g__", ""))

genus_in_metaphlan <- metaphlan_taxa %>% tibble() %>% set_names("Phylum_Genus")

genus_in_metaphlan %<>% mutate(Phylum_Genus = str_replace(Phylum_Genus, ".+ ", ""))

intersect(genus_in_16s, genus_in_metaphlan)

library(VennDiagram)

venn.diagram(list("16S" = genus_in_16s$Phylum_Genus, "Metaphlan2" = genus_in_metaphlan$Phylum_Genus), filename = "Venn_diagram_of_genus_level_metaphlan_and_16s_matches.png",
             imagetype = "png",
             height = 1000, width = 1000, col = "transparent",
	fill = c("cornflowerblue", "darkorchid1"),
	cat.pos = c(-20,20),
	cat.dist = c(.05,.05),
	margin = .05)

# venn.diagram(list("16S" = genus_in_16s$Phylum_Genus, "Metaphlan2" = genus_in_metaphlan$Phylum_Genus), filename = "Venn_diagram_of_genus_level_metaphlan_and_16s_matches.png", height = 1000, width = 1000, col = "transparent",imagetype = "png",
# 	fill = c("cornflowerblue", "darkorchid1"),
# 	cat.pos = c(-20,20),
# 	cat.dist = c(.05,.05),
# 	margin = .05)

#grid.draw(venn.plot)

#
```

<!-- ![' '](Venn_diagram_of_genus_level_metaphlan_and_16s_matches.png)\ -->

\newpage

#Individual taxa linear models

We will use the metaphlan results since they are the most comprehensive at the species level.

```{r preparing for tests}

resetSampleSheet <- function(s) {
  s <- s %>%
  filter(!isControl) %>%
  mutate(SubjectID = factor(SubjectID))
  return(s)
}

s_toTest <- resetSampleSheet(s)

#This is where we can also select only taxa that are on average
# 1 % abundant or above in each sample
# top_taxa <- props[,s_toTest$SampleID] %>%
#   apply(1, mean) %>%
#   sort(decreasing=T)

frac_cutoff = 0.2

rows_to_keep <- filter_low_coverage(props[,s_toTest$SampleID], frac_cutoff)

top_taxa <- rownames(props[rows_to_keep,s_toTest$SampleID])

#top_taxa <- names(top_taxa[top_taxa > 0.001])

# proportion based lm (for taxa abundances)
run_lm_props <- function(props_toTest, s_toTest, form1, p_cutoff) {
  props_toTest[,s_toTest$SampleID] %>%
    rownames_to_column(var = "Taxa") %>%
    gather(key = "SampleID", value = "props", -Taxa) %>%
    mutate(props = props+1E-6) %>%
    merge(s_toTest, by="SampleID") %>%
    mutate(props_logit = log(props/(1-props))) %>%
    group_by(Taxa) %>%
    do(tidy_lm(lm(as.formula(form1), data=., na.action=na.omit))) %>%
    setNames(c("Taxa","term","Estimate","Std.Error","t.value","p.value")) %>%
    ungroup() %>%
    filter(term != '(Intercept)') %>%
    group_by(term) %>%
    mutate(fdr = p.adjust(p.value, method="BH")) %>%
    ungroup() %>%
    filter(p.value < p_cutoff) 
}

```

To filter out taxa that are rare, we will select for those that are present in at least `r paste0(frac_cutoff*100,'%')` of samples.

*Details of tests*

Here, we logit transform the abundance values because they are not normally distributed. Formula: logit(Abundance) = log(Abundance / (1 - Abundance)).

How to read the table:

Taxa is the species / genera / family / other taxonomic level in question.

term is the predictive variable(s) in question.

Value is the predicted change in logit transformed abundance due to the predictive variable(s).

Standard error is a measure of variability of said Value.

DF is the degrees of freedom. As we add more terms to the linear model, the degrees of freedom decreases. 

t.value is the output of the t-test of the changes in abundance by the predictive variable(s).

p.value is the probabability that we can reject the null hypothesis that there is no change in the abundance due to the variables. The null hypthosesis, expressed another way, is the scenario where the coefficients of all predictive variables are 0; thus, the outcome variable equals the intercept in the linear model.

fdr is the false-detection rate. It is a p.value adjusted for the multiple t-tests being conducted at once on all Taxa above 1% mean abundance.

##Age differences

Before subsetting into adults and children, let's see if age has an effect on any Taxa.

```{r}

age_tests <- function() {
s_toTest <- resetSampleSheet(s)

s_toTest %<>%
  mutate(age = as.numeric(age))

form1 <- "props_logit ~ age"
props_toTest <- props[top_taxa,s_toTest$SampleID]

summaries_df <- run_lm_props(props_toTest, s_toTest, form1, 0.05)

return(summaries_df)
}

age_tests() %>%
  pander(split.table=Inf, digits=2, caption = "Linear model fit by method of least-squares, Formula: logit(Abundance) ~ age")

```

###Scatterplots for age differences

First, we will do standard scatterplots. Then, we will construct plots with Loess curve-fitting and add spearman rank-correlation statistics due to the presence of many zero's.

```{r fig.height=8, fig.width=12}

to_select <- age_tests() %>%
  filter(fdr < 0.05) %>%
  select(Taxa) %>%
  unique

props[to_select$Taxa, s_toTest$SampleID] %>%
  rownames_to_column(var = "Taxa") %>%
  gather(key = "SampleID", value = "props", -Taxa) %>%
  mutate(props = props+1E-6) %>%
  merge(s_toTest, by="SampleID") %>%
  
  mutate(Taxa = sub(" ", "\n", Taxa)) %>%
  mutate(Taxa = reorder(Taxa, -props)) %>%
  ggplot(aes(x=age, y=props, color=study_group)) + 
    #geom_boxplot(outlier.alpha = 0) +
    #geom_quasirandom(dodge.width = 0.75) +
    geom_point() +
    theme_bw() +
    theme(
      axis.text.x = element_text(angle=45, vjust=1, hjust=1),
      strip.background = element_blank()) +
    #scale_color_manual(values=brewer.pal(8, "Set1")[c(2,5,1)]) +
    scale_color_brewer(palette = "Set2") +
    scale_y_continuous(trans = "logit") +
    facet_wrap(~Taxa, scales="free_y", ncol=3) +
    labs(x="Age", color="Medium/LowUrban",
         shape="",
         y="Logit transformed abundance", 
         title = "Taxa abundances by age")

# a neat little package that does the correlation plots and puts the p.values on the graph
library("ggpubr")

toPlot <- props[to_select$Taxa, s_toTest$SampleID] %>%
  rownames_to_column(var = "Taxa") %>%
  gather(key = "SampleID", value = "props", -Taxa) %>%
  mutate(props = props+1E-6) %>%
  merge(s_toTest, by="SampleID") %>%
  
  mutate(Taxa = sub(" ", "\n", Taxa)) %>%
  mutate(Taxa = reorder(Taxa, -props))

ggscatter(data = toPlot, y = "props", x = "age", color = "study_group", 
          add = "loess", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "spearman", facet.by = "Taxa",
          ggtheme = theme_bw(), palette = "Set2") +
    facet_wrap(~Taxa, scales="free_y", ncol=3) +
    labs(x="Age", color="",
         shape="",
         y="Logit transformed abundance", 
         title = "Taxa abundances by age")

```

##Adults

###Urbanicity

Due to the differences in age, we will subset the participants into adults (age > 16) and children (age <= 16) before addressing our most important question: Does access to Western medicine (MediumUrban) have an effect on Taxa abundances?

```{r}

urban_tests <- function() {
s_toTest <- resetSampleSheet(s)

s_toTest %<>%
  mutate(study_group = fct_relevel(study_group, "LowUrban")) %>%
  mutate(age = as.numeric(age)) %>%
  filter(age > 16)

form1 <- "props_logit ~ study_group + age"
props_toTest <- props[top_taxa,s_toTest$SampleID]

summaries_df <- run_lm_props(props_toTest, s_toTest, form1, 0.05)

return(summaries_df)
}

urban_tests() %>%
  mutate(term = gsub("study_group","",term)) %>%
  pander(split.table=Inf, digits=2, caption = "Adult tribal members (age > 16).\nLinear model fit by method of least-squares,\nReference level is LowUrban.\nFormula: logit(Abundance) ~ Medium/LowUrban + age.")

```

###Swarmplots for urbanicity differences

Since some Taxa are approaching significance, we will graph the differences.

```{r fig.height=8, fig.width=12}

to_select <- urban_tests() %>%
  select(Taxa) %>%
  unique

props[to_select$Taxa, s_toTest$SampleID] %>%
  rownames_to_column(var = "Taxa") %>%
  gather(key = "SampleID", value = "props", -Taxa) %>%
  mutate(props = props+1E-6) %>%
  merge(s_toTest, by="SampleID") %>%
  filter(age > 16) %>%
  mutate(age_level = case_when((age > 16 & age <= 26) ~ "16 < age <= 26",
                               (age > 26 & age <= 36) ~ "26 < age <= 36",
                               (age > 36 & age <= 46) ~ "36 < age <= 46",
                               (age > 46) ~ "age > 46")) %>%
                                
  mutate(Taxa = sub(" ", "\n", Taxa)) %>%
  mutate(Taxa = reorder(Taxa, -props)) %>%
  ggplot(aes(x=study_group, y=props, color=age_level)) + 
    #geom_boxplot(outlier.alpha = 0) +
    geom_quasirandom(dodge.width = 0.75) +
    theme_bw() +
    theme(
      axis.text.x = element_text(angle=45, vjust=1, hjust=1),
      strip.background = element_blank()) +
    #scale_color_manual(values=brewer.pal(8, "Set1")[c(2,5,1)]) +
    scale_color_brewer(palette = "Set2") +
    scale_y_continuous(trans = "logit") +
    facet_wrap(~Taxa, scales="free_y", ncol=3) +
    labs(x="", color="Age categories",
         shape="",
         y="Logit transformed abundance", 
         title = "Taxa abundances by Medium or Low Urban",
         subtitle = "Subset is Adults (age > 16)")
```

##Village differences

Next, we will test for differences in villages. We will use a Kruskal-wallis rank-based test (non-parametric version of ANOVA).

```{r}

run_kruskal_props <- function(props_toTest, s_toTest, form1, p_cutoff) {
  props_toTest[,s_toTest$SampleID] %>%
    rownames_to_column(var = "Taxa") %>%
    gather(key = "SampleID", value = "props", -Taxa) %>%
    mutate(props = props+1E-6) %>%
    merge(s_toTest, by="SampleID") %>%
    mutate(props_logit = log(props/(1-props))) %>%
    group_by(Taxa) %>%
    do(broom::tidy(kruskal.test(as.formula(form1), data=., na.action=na.omit))) %>%
    select(-method) %>%
    setNames(c("Taxa","statistic","p.value","degrees of freedom")) %>%
    ungroup() %>%
    mutate(fdr = p.adjust(p.value, method="BH")) %>%
    filter(p.value < p_cutoff) 
}

village_kruskal <- function() {
  
s_toTest <- resetSampleSheet(s)

s_toTest %<>%
  mutate(village = fct_relevel(village, "Kanarakuni")) %>%
  filter(age > 16)

form1 <- "props_logit ~ village"

summaries_df <- run_kruskal_props(props[top_taxa,s_toTest$SampleID], s_toTest, form1, 0.05)

return(summaries_df)

}

village_kruskal() %>%
  pander(split.table=Inf, digits=2, caption = "Adult tribal members (age > 16).\nKruskal-Wallis rank sum test\nFormula: logit(Abundance) ~ village")

```

##Swarmplots for village differences

Since some Taxa are approaching significance, we will graph the differences.

```{r fig.height=8, fig.width=12}

to_select <- village_kruskal() %>%
  select(Taxa) %>%
  unique

props[to_select$Taxa, s_toTest$SampleID] %>%
  rownames_to_column(var = "Taxa") %>%
  gather(key = "SampleID", value = "props", -Taxa) %>%
  mutate(props = props+1E-6) %>%
  merge(s_toTest, by="SampleID") %>%
  mutate(village = fct_relevel(village, "Kanarakuni")) %>%
  filter(age > 16) %>%
  
  mutate(Taxa = sub(" ", "\n", Taxa)) %>%
  mutate(Taxa = reorder(Taxa, -props)) %>%
  ggplot(aes(x=village, y=props, color=study_group, shape=ethnicity)) + 
    #geom_boxplot(outlier.alpha = 0) +
    geom_quasirandom(dodge.width = 0.75) +
    theme_bw() +
    theme(
      axis.text.x = element_text(angle=45, vjust=1, hjust=1),
      strip.background = element_blank()) +
    #scale_color_manual(values=brewer.pal(8, "Set1")[c(2,5,1)]) +
    scale_color_brewer(palette = "Set2") +
    scale_y_continuous(trans = "logit") +
    facet_wrap(~Taxa, scales="free_y", ncol=3) +
    #facet_grid(Taxa~ethnicity, scales="free_y", space="free", drop=T) +
    labs(x="", color="Medium or Low Urban",
         shape="Ethnicity",
         y="Logit transformed abundance", 
         title = "Taxa abundances by village, categorized by urbanicity")
```



```{r eval=FALSE, include=FALSE}

# Appendix

## Number of reads before and after trimmming Illumina adapter sequences with Trimmomatic.

preprocess %>%
  select(
    Sample = Samples,
    Input = input,
    Dropped = dropped,
    `Forward only` = fwd_only,
    `Reverse only` = rev_only,
    `Both kept` = both_kept) %>%
  #View()
  pander(split.table = Inf)
```

```{r eval=FALSE, include=FALSE}

## Number of reads before and after filtering of host genome sequence.

preprocess %>%
  mutate(
    `Percent host reads` = 100 * host / (host + nonhost),
    `Percent host reads` = round(`Percent host reads`, 2)) %>%
  select(
    Sample = Samples,
    `Host reads` = host,
    `Non-host reads` = nonhost,
    `Percent host reads`) %>%
  #View()
  pander(split.table = Inf, big.mark = ',')
```

# Comparing Amerindian children to age-matched Western microbiomes

```{r combining and summarizing}

# This is how Jung-Jin subsampled the DYNAMIC samples and is maybe how it should be done here
# TODO if needed

# tob_fp <- "../../6_Misc/R_utils/all_healthy_feces_metadata.xlsx"
# tob <- read_tsv("../../6_Misc/dynamic_ceylan/metadata.tsv") %>%
#   filter(SampleType == "Feces", redcap_event_name == "Baseline Visit") %>%
#   filter(study_group %in% c("Healthy<6", "Healthy>=6")) %>%
#   mutate(age_yrs = as.numeric(age_yrs)) %>%
#   select(SampleID, SubjectID, SampleType, age_yrs, sex, Run) %>%
#   rename(Sex = sex, Age_yrs = age_yrs) %>%
#   mutate(Group = "DYNAMIC") %>%
#   arrange(Age_yrs) %>%
#   rownames_to_column("line") %>%
#   mutate(ageCat = cut(Age_yrs, breaks = ageBreaks)) 
# 
# set.seed(2019)
# # randomly select 18 from (0,3]
# tob1 <- tob %>%
#   filter(ageCat == "(0,3]") %>%
#   sample_n(18)
# # randomly select b from (3,6]
# tob2 <- tob %>%
#   filter(ageCat == "(3,6]") %>%
#   sample_n(8)
# # will use all 26 samples from (6,18]
# tob3 <- tob %>%
#   filter(ageCat == "(6,18]")
# 
# tobPick <- bind_rows(tob1, tob2, tob3)

s_bello <- s2 %>%
  mutate(study = "Amerindian") %>%
  filter(!is.na(age))


s_dynamic <- read_rds(here("metagenomics/Data","s_feces.RDS"))

dynamic_md <- s_dynamic %>%
  filter(study_group %in% c("Healthy>=6", "Healthy<6")) %>%
  filter(!(SubjectID %in% c("Subj 5"))) %>%
  # mutate(study_week = if_else(visit=="Baseline Visit", "0",
  #                            if_else(visit=="Visit 2", "4",
  #                                    if_else(visit=="Visit 3", "8", "None")))) %>%
  # mutate(study_week = as.double(study_week)) %>%
  # select(-visit) %>%
  mutate(study = "Western") %>%
dplyr::rename(age = age_yrs)


all_md <- bind_rows(dynamic_md, s_bello)

#Summary statistics:
summarydf <- all_md %>% select(SubjectID, study) %>%
  mutate(study = as.factor(study)) %>%
  mutate(SubjectID = as.factor(SubjectID)) %>%
  group_by(study) %>% distinct(SubjectID) %>% count(study)

summarydf %>%
  mutate(`Age range:` = if_else(study %in% "Western", paste(round(min(dynamic_md$age)), "-", round(max(dynamic_md$age))), paste(round(min(s_bello$age)), "-", round(max(s_bello$age))))) %>%
  rename(Study = study) %>%
  pander(split.table=Inf, digits=2, caption = "Amerindian children and western controls")

```

We will now match the ages and summarize the counts of people in each study.

```{r}

s_bello_2 <- s_bello %>%
  filter(age > round(min(dynamic_md$age))) %>%
  filter(age < round(max(dynamic_md$age)))

all_md_2 <- bind_rows(s_bello_2, dynamic_md)

#Summary statistics:
summarydf <- all_md_2 %>% select(SubjectID, study) %>%
  mutate(study = as.factor(study)) %>%
  mutate(SubjectID = as.factor(SubjectID)) %>%
  group_by(study) %>% distinct(SubjectID) %>% count(study)

summarydf %>%
  mutate(`Age range:` = if_else(study %in% "Western", paste(round(min(dynamic_md$age)), "-", round(max(dynamic_md$age))), paste(round(min(s_bello_2$age)), "-", round(max(s_bello_2$age))))) %>%
  rename(Study = study) %>%
  pander(split.table=Inf, digits=2, caption = "Amerindian children and western controls\nNumbers may appear off due to rounding but source data is preserved")

```

# Age distributions

Let us also examine the age distributions with histograms:

```{r}

# library(esquisse)
# 
# esquisser(all_md_2)
# 

ggplot(all_md_2) +
 aes(x = age, fill = study) +
 geom_histogram(bins = 30L) +
 theme_minimal() +
 facet_wrap(vars(study))

ggplot(all_md_2) +
 aes(x = age, fill = study) +
 geom_density(adjust = 1L) +
 theme_minimal() +
 facet_wrap(vars(study))

#could we do something like
# for each (age in amerindian_children)
#   take 1 matched-age child from Western children
# that way it would be 1:1 matching like in a case-control experiment!
# test1 <- all_md_2 %>% mutate(age_rounded = round(age, 0))



```


```{r smoosh two metaphlans together}

#metaphlan from bello analysis is called props_g
bello_props <- props

#the other other metadata
other_md <- read_tsv(here("metagenomics/Data","dynamic_metaphlan_results","samples.tab")) %>%
  rename(SampleID = tmp_sample) %>%
  filter(env_material == "Feces") %>%
  filter(study_group %in% c("Healthy under 5","Healthy over 5")) %>%
  mutate(study = "Western")

metaphlan_dynamic <- read_tsv(here("metagenomics/Data","dynamic_metaphlan_results","metaphlan_taxonomic_assignments.tsv"))
colnames(metaphlan_dynamic) <- str_replace(colnames(metaphlan_dynamic), "_review", "")

metaphlan_healthy <- metaphlan_dynamic %>%
  gather(key="SampleID", value = "Proportion", -Term) %>%
  filter(SampleID %in% (other_md %>% pull(SampleID)))

props_dynamic <- metaphlan_healthy %>%
  spread(key = "SampleID", value = "Proportion")

o2 <- props_dynamic %>%
  column_to_rownames(var = "Term") %>%
  clean_taxonomy()

# Metadata in the form of truncated green genes assignments
md <- sub("(; [kpcofgs]__)+$", "", rownames(o2), perl=T)
md <- gsub("[kpcofgs]__", "", md)  

# Assignments data-frame
adf <- split_assignments(md, split="\\|") %>%
  mutate(Species = ifelse(!is.na(Genus) & !is.na(Species), paste(Genus, Species), NA))

a <- simplify_assignments(adf, rank1 = "Phylum", rank2="Species")

dynamic_props <- rowsum(o2, a)

# Only neundreizig different taxa
# length(setdiff(rownames(bello_props),rownames(dynamic_props)))
# [1] 39

bello_props_df <- bello_props %>%
  rownames_to_column(var = "Taxa") %>%
  gather(key = "SampleID", value = "Prop", -Taxa)

dynamic_props_df <- dynamic_props %>%
  rownames_to_column(var = "Taxa") %>%
  gather(key = "SampleID", value = "Prop", -Taxa) %>%
  filter(Taxa %in% bello_props_df$Taxa)

all_props_df <- bind_rows(bello_props_df, dynamic_props_df)

```


## Bray-curtis distances to centroids

First we will look at how overall similar the participants are based on their taxonomic abundances of bacteria. For this, we will calculate the bray-curtis distance among all samples, and then we will compare individual samples' distances to group centroids (the groups being the two studies).

```{r bc_all}

all_md_3 <- bind_rows(s_bello_2, other_md)

props_all <- all_props_df %>%
  spread_to_numeric_matrix(., "Taxa", "SampleID", "Prop")

bc <- vegdist(t(props_all))

dist_all <- usedist::dist_subset(bc, all_md_3$SampleID)

all_md_3 %<>%
  mutate(age_class = case_when((age < 5) ~ "Age < 5 yrs",
                               (age >= 5) ~ "Age >= 5 yrs",
                              str_detect(SampleID, '(?i)(lessthan5)') ~ "Age < 5 yrs",
                              str_detect(SampleID, '(?i)(greaterthan5)') ~ "Age >= 5 yrs",
                              (study_group %in% c("Healthy over 5")) ~ "Age >= 5 yrs",
                              (study_group %in% c("Healthy under 5")) ~ "Age < 5 yrs")) %>%
  mutate(study_by_age = paste0(study, " ", age_class))

make_pcoa_plot_with_closed_and_open_circles_for_points(dist_all, all_md_3, color_by = "study", shape_by = "age_class")

bc_cease <- dist_to_centroids(dist_all, all_md_3$study_by_age, squared = T) %>%
  filter(CentroidGroup %in% "Amerindian Age < 5 yrs")

bc_cease %>%
  mutate(CentroidDistance = sqrt(CentroidDistance)) %>%
  rename(SampleID = Item) %>%
  left_join(all_md_3, by="SampleID") %>%
  ggplot() +
  geom_boxplot(aes(x=study_by_age, y=CentroidDistance)) +
  theme(
      axis.text.x = element_text(angle=45, vjust=1, hjust=1), strip.background = element_blank()) +
  labs(title = "Distance to 'Amerindian Age < 5 yrs' centroid for each sample")
#bc_feces_dysbiosis <- dist_to_centroids(bc_feces, s_feces$study_group, squared = T) 

```

\newpage

### Permanova and Dispersion

Next, we ask the question: are the study groups significantly different overall. For this, we can run Permanova on the centers of the dispersions.

```{r echo=FALSE}
# adtable <- adonis(dist_all ~ all_md_3$study + all_md_3$age_class)
# 
# as.data.frame(adtable$aov.tab) %>%
# pander(split.table=Inf, digits=2, caption = "Permanova for centers of dispersion")

adtable <- adonis(dist_all ~ all_md_3$study_by_age)

as.data.frame(adtable$aov.tab) %>%
pander(split.table=Inf, digits=2, caption = "Permanova for centers of dispersion")
```

We can also compare the dispersions (spread) of the distances for each group.

```{r echo=FALSE}

betatable <- betadisper(d = dist_all, group = all_md_3$study_by_age)

betatable

```

\newpage


## Heatmap

Next, we will construct a heatmap of taxa abundances.

```{r}
prop_cut <- 0.05
satu_limit <- 0.4
heatmap_fp <- "Amerindian_children_compared_to_Western_children.pdf"

s_toPlot <- all_md_3

```

Taxonomic assignments were performed using the Metaphlan program.

Heatmap charts were generated from the taxonomic assignments. Each column represents one sample and each row represents one taxon (typically a species). Ranks are included in the plot if the taxon is present in `r 100*prop_cut`% abundance in at least one sample.

The chart is colored white if species were not observed in the sample, dark blue if species were observed at very low abundance.  This allows the reader to quickly survey species presence/absence.  Abundance values exceeding 40% are colored red, indicating an extremely dominant species.

`r {paste0("Please see attached plot ", heatmap_fp, ".")}`

\blandscape

```{r heatmap Amerindian -> Dynamic, fig.height=8, fig.width=12}

names(a) <- names(md)

props_toPlot <- props_all[,all_md_3$SampleID]

grps <- c("study","age_class")

heatmap_grouped(props_toPlot, s_toPlot, grps=grps, option=2, prop_cut = prop_cut, satu_limit=satu_limit, here("metagenomics","Output", heatmap_fp))
#, taxa = a

```

\elandscape


```{r savepoint, eval=FALSE, include=FALSE}
save.image(file = here("metagenomics","Data","2019-12-05_bello_data.RData"))
```


<!-- Begin, Children reports -->

```{r run child reports, child=here::here("Scripts","Rmds","Functional_comparison.Rmd")}

```

<!-- End, Children reports -->

```{r fun stuff, eval=FALSE, include=FALSE}
#fun stuff
# library(systemfonts)
# library(esquisse)
```


<!-- Notes -->
```{r generate dated report, eval=FALSE, include=FALSE}
library(here)
rstudioapi::documentSaveAll()
#notes
#neat: you can run this following command in the console to give your reports custom names (or date-stamp them)
rmarkdown::render(here("metagenomics",'Scripts','Rmds','Bello_amerindian_peoples_metaphlan2_taxonomy_and_kegg_pathways.Rmd'),output_file = here('Output',paste0('Amerindian_peoples_microbiome_',Sys.Date(),'.pdf')))

```
<!-- ===== -->
